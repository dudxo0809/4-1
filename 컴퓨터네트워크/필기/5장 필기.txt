p. 과제

Bidirectional Go back N

	-> 응용계층에서 시뮬레이션 할수 있는 코드를 구현
	-> User space에서 동작하는 코드를 구현
		-> 원래는 커널에 구현되는 코드지만
		-> 응용계층에서 동작을 흉내 내보는것
	-> 시뮬레이션이기때문에 시간은 확률적으로 추정해서 동작하게함
	-> 이벤트가 발생할 시점이 확률적으로 결정됨
	-> 이벤트에 따라 일어나야할 동작들을 구현하는것! (FSM)

	시뮬레이션에 구현되어있는 함수들을 적절히 배합해서 쓸것
	-> timerinterrupt handler의 동작을 구현 등
	-> 체크섬 구현은 extra credit임 (bit-wise addition 방법을 사용해야함)
			-> bit별로 덧셈
	-> Piggybacking : 양방향일때 ACK를 보낼때 data를 같이 보내는것

Stop and Wait를 먼저 구현하고 단계적으로 뼈대에 살을 붙이는걸 추천함
	-> 단방향 GBN구현 -> 양방향 GBN
	일부 기능이라도 구현하면 부분점수 있음

------------------------------------------------------------------------------------------------
p. 과제 pdf

Alternating-Bit-Protocol : Stop&Wait 는 제출안해도 되지만
	-> 이걸 먼저 구현하고 여기에 살을 붙이는게 편함

A와 B쪽을 구현하는것
최종적으로는 양방향을 구현해야함

upper Layer : 응용계층에서 데이터가 내려옴
	-> 내려온 데이터를 어떻게 처리할지를 구현
	-> Init : 기본적인 초기화 함수
	-> Timerinterrupt가 호출되면 타이머가 만료되었다는것
		-> 재전송을 구현해야함
	-> Timer를 설정하고, 재설정하고, 강제종료하는것은 함수를 호출해서 구현
	
	-> 아래 계층에서 ACK 넘버를 받으면 맞는지 아닌지에 따라 동작을 구현
	-> 네트워크 계층으로 패킷을 내려보내는것 까지 구현하고 네트워크계층은 시뮬레이션이 알아서 해줌
	-> 패킷의 bit에러나 로스가 발생하는것등의 이벤트를 처리해줘야함

	B에서 패킷을 받으면 이를 처리하고 응용계층으로 보냄
	-> 패킷을 받으면 그냥 올려보내면 됨 (뭐 재조하하고 그런거 X)
	-> 20글자의 string 데이터가 전송될것, 패킷 구조체도 있음
	prog.c 코드의 비어있는 함수를 채우면됨!

	Tracing : 디버깅할때 활용 : 제출시에는 X



양방향을 구현할때 NAK쓰지말고 ACK 번호가 다르면 NAK로 인지

코드, 디자인 문서, 샘플 출력한것 전부 제출해야함


체크섬 구현할때 10진수 덧셈으로 구현하면 extracredit은 받지 못함
	-> 제대로된 1's compliment addition을 사용한 덧셈방법을 사용할것

-----------------------------
조교님 과제설명

센더가 리시버역할도 하고, 리시버도 센더역할을 하는 양방향 GBN

	코드관련질문 김동주조교님께 할것


------------------------------------------------------------------------------------------------
p. 4

Transport Layer

3장에서는 전송계층의 원리를 배움
	프로토콜 : 멀티플렉싱, UDP등의 패킷의 포맷
	GBN 등등

이번에는 TCP를 배워볼것

Connection-Oriented Transport : TCP

------------------------------------------------------------------------------------------------
p. 6

TCP는 계속해서 업데이트가 되어왔음

	Point to Point 프로토콜 : 센더와 리시버가 하나
	순차적으로 한글자씩 데이터를 전송(여러개를 모아서 하나의 세그먼트로)
	파이프라인 사용 : 윈도우를 사용
	센더와 리시버 모두 버퍼가 있음
	Full duplex : 커넥션을 열면 양쪽으로 data,ACK를 전송
		MSS가 정해짐 : 이 size에 맞게 쪼개서 보내야 효율적
	Connection Setup : 핸드쉐이킹 : 커넥션이 설정된 후에야 데이터를 전송
	Flow Control : 센더가 패킷을 너무빠른속도로 보내면 리시버가 소화를 못함
		-> 리시버의 버퍼가 꽉차면 손실이나는데
		-> 이를 방지해주는 매커니즘이 TCP에 적용됨


------------------------------------------------------------------------------------------------
p. 7

TCP segment

	가로축이 4byte
	20byte까지 헤더, 그 이후부터 데이터 : 옵션은 변동적

시퀀스번호 : byte stream의 번호
	B도 A에게 데이터를 보낼 수 있음

ACK : 다음에 받을 seq번호를 보냄
	-> 만약 이 seq번호와 ACK번호가 다르면 뭔가 잘못된것임


------------------------------------------------------------------------------------------------
p. 9

TCP에서 Timeout은 어떻게 되어있나
	-> TCP는 이 타이머에 따라 성능이 크게 갈림!!
	-> 타이머 값이 너무 짧으면 불필요한 재전송을 할 수 있고,
		너무 길면 성능이 떨어진다.

가장 좋은것은 round trip time에 맞추면 되는데 사실 이 시간은
	네트워크 상황에 따라 계속 달라짐
	-> 최근에 샘플링한 값들의 평균에 맞춤

------------------------------------------------------------------------------------------------
p. 10

RTT의 추정치 :  최근의 RTT와 과거의 누적 RTT를 적절히 합친다.

파란색 선 : sample RTT
	-> estimate를 사용하니 smoothing이 됨
	-> 최근의 값을 일부 적용해 변화를 완화시킴

	-> 변화가 크지 않아 위험성은 적어지지만,
		실제 측정값과는 차이가 클 수 있음

------------------------------------------------------------------------------------------------
p. 12

이를 다시 보완해 Deviation을 포함함

	-> 

------------------------------------------------------------------------------------------------
p. 13

TCP reliable data transfer

	-> gobackN의 기본특성 두가지(파이프라인, 누적ack)를 기반으로 함
	-> timeout이 되면 재전송하는것은 똑같다
	-> duplicate ack가 발생해도 재전송

GBN을 기반으로한 TCP의 기본에대해 알아보자!

------------------------------------------------------------------------------------------------
p. 14

윗계층으로부터 데이터를 받을때
	-> seq#와 함께 세그먼트 생성
	-> 타이머 가동(타이머가 하나이므로 이전의 타이머 유지)
	-> timeout interval 설정해야함

시간초과
	-> 재전송해야함 : 윈도우에있는것을 모두 다시보내야함
	-> 타이머 재시작

아랫계층으로부터의 ACK를 받을때

	-> 잘 수신된 ACK까지는 재전송x : 다음으로 base를 옮김

------------------------------------------------------------------------------------------------
p. 16

무한루프를 돌면서 각 이벤트에대한 처리를 하는 수도코드

	이 수도코드 잘보고 과정을 이해할것
	length(data) : 데이터의 byte수


------------------------------------------------------------------------------------------------
p. 17

ACK가 사라진 상황

	-> ACK100이 가다가 소실됨
	-> timeout이 되었으므로 재전송해야함
		-> A에서 다시보내고 이번엔 ACK100을 잘 보냄

일찍 timeout된 상황

	-> Host B가 ACK를 다 잘 보냈지만 timeout이됨
	-> 두번째 재전송한 92seq가 보내지고 얼마뒤 ACK100이 들어옴
	-> 그리고 ACK120이 들어오고 ACK 120이 재전송되지만 Host A에서는 이를 무시함


------------------------------------------------------------------------------------------------
p. 18

재전송하는 경우

ACK100이 소실이 되었지만 seq100은 잘 받았으므로 ACK120을 보냄

	-> 다시 Host A에서는 ACK100에 대해 timeout이 되었으므로
	-> 다시 보내게 됨

------------------------------------------------------------------------------------------------
p. 19

TCP ACK생성 시나리오
4가지 시나리오에 따른 상황대처

다 잘맞을때 : 



------------------------------------------------------------------------------------------------
p. 20

Flow Control

	-> TCP의 flow control : 흐름 제어
	-> 센더가 패킷을 너무빨리 보내서 리시버의 버퍼가 넘치지 않게 함
		-> 센더가 속도조절을 함

------------------------------------------------------------------------------------------------
p. 22

TCP 연결 셋업

	-> 처음 센더와 리시버 사이에 초기화를 진행
		-> 시퀀스 번호, 버퍼, RcvWindow사이즈
	-> 클라이언트가 TCP SYN segment를 서버로 보냄(seq#를 실어보냄)
	-> 서버가 syn을 받고 STNACK를 클라이언트로 보내줌
	-> 클라이언트가 SYNACK를 받고 ACK segment와 함께 data를 보냄

	-> 3-way handshake 이 과정이 1Round trip

------------------------------------------------------------------------------------------------
p. 24

연결 해제 과정은 4-way의 과정이다.

	-> 클라이언트가 FIN을 받으면 약 30초 뒤에 close함
	-> 각각 FIN을 받으면 ACK를 보냄


------------------------------------------------------------------------------------------------
p. 28

Congestion Control : 병목 제어

기본 매커니즘은 additive increase와 multiplicative decrease이다.

	-> time out이 발생하면 : 병목이 발생했다고 판단!

	-> 시간이 흘러감에 따라 congestion이 어떻게 변하는가의 그래프
	-> 병목이 발생하지 않은것으로 추정되면, 조금씩 속도를 높이자!
	-> 병목이 발생한것으로 추정되면(time out), 속도를 절반으로 줄인다 

------------------------------------------------------------------------------------------------
p. 32

위에서 전송요청이 와도 window size보다 크면 거부했었음

	-> 이제는 congestion window size보다 작아야함
		-> 이변수는 변동적임 (그러나 maximum window size보다는 작음)
	-> 실질적인 전송속도 : rate = ConWin/RTT (Bytes/sec)


------------------------------------------------------------------------------------------------
p. 34, 35

처음엔 하나만 보내다가, ACK가 올때마다 조금씩 증가시킴
	-> 1->2->4->8->...

일정 threshold만큼 exp로 증가하다가 linear하게 증가로 바뀜
	-> timeout이 발생하면 너무 과하게 떨구지 말고 절반만
	-> Loss가 발생하면 1로 떨궜음

------------------------------------------------------------------------------------------------
p. 






------------------------------------------------------------------------------------------------
p. 






------------------------------------------------------------------------------------------------
p. 






------------------------------------------------------------------------------------------------
p. 






------------------------------------------------------------------------------------------------
p. 






------------------------------------------------------------------------------------------------
p. 






------------------------------------------------------------------------------------------------
p. 






