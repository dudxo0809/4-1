p. 2

이번장에서는 응용계층에 대해 설명한다





------------------------------------------------------------------------------------------------
p. 4

네트워크앱은 2가지로 나뉘어 만들어져야한다.

	-> 네트워크 코어에서는 패킷을 전달하는것 말고는 다른기능이 없다
	-> 브라우저와 웹서버에서 프로그램의 대부분을 차지



------------------------------------------------------------------------------------------------
p. 5

서버
	-> 호스트, 고정 IP, 물리적 서버를 여러개 운영함(서버가 복제된 형태)

클라이언트
	-> 서버와 통신, IP가 바뀔수있음
	-> 클라이언트끼리 통신하지 않음



------------------------------------------------------------------------------------------------
p. 7

프로세스간의 통신

	프로세스 : 호스트에서 수행되는 중인 프로그램
	inter-process communication : 같은 호스트 안에서도 프로세스끼리 통신을 할 수 있다
	message exchange : 서로 다른 호스트에서의 프로세스끼리의 통신

	P2P는 클라이언트 기능과 서버기능 모두 탑재를 해야한다

------------------------------------------------------------------------------------------------
p. 8

소켓

프로세스는 소켓을 통해 메시지를 전송하고 받는다
	-> 소켓에 연결된 데이터는 알아서 이어진 소켓으로 전송된다

	API
	-> transport 프로토콜을 선택하는 함수 (TCP, UDP 등)
	-> 몇몇 파라미터를 설정하는 함수

	순서)
	1. 응용 프로세스에서 소켓의 함수를 호출함
	2. 소켓을 통해 메시지가 전달됨 (TCP는 OS에 탑재됨)
	3. 인터넷을따라 소켓을 통해 상대방에게 전달됨


------------------------------------------------------------------------------------------------
p. 9

Addressing Process

	-> 호스트는 자기자신만의 32bit IP주소를 가지고 있다.
		-> 그러나 주소만 가지고 있으면 안된다!
		-> 인터넷을 따라 오는건 IP주소 하나면 되지만
		-> 어떤 프로세스에 전달할지는 port number에 따라 정해진다

	Port number : 호스트의 프로세스와 관련!
	well-known port number : 인터넷 표준으로 정해진 포트넘버가 있음

	메시지를 교환하기 위해선 IP주소와 port넘버가 필요하다


------------------------------------------------------------------------------------------------
p. 10

App Layer의 프로토콜

	-> 메시지를 정의한다
		-> 메시지의 종류와 메시지의 필드를 정의함
		-> 언제 어떤 메시지를 전송하고 교환하는지, 응답으로는 어떤 메시지를 전달하는지
	Public domain protocols 
		-> RFC문서에 정의됨, 연동에 주안점을 둠, HTTP, SMTP (공익적인 목적에 초점을 둠)
	Proprietary protocols
		-> 기업이 이윤을 추구하기 위해 만듬, Skype

------------------------------------------------------------------------------------------------
p. 11

응용계층에서의 Transport service는 무엇을 할까???

	-> 응용계층은 transport 계층의 기능을 가져다 씀
	-> Data Integrity : 데이터의 전송에 오류가 있어도 되는지 아닌지 (데이터의 무결성)
		-> TCP는 오류가 발생하지 않는 서비스임(발생해도 다 복구해줌)
		-> ex.) 오디오는 오류가 조금 있어도됨 , 은행서비스는 오류가 있으면 안됨!
	-> Throughput : 전송속도
		-> 일부 app은 약간의 오류가 있어도 throughput이 더 중요하다 (스트리밍 등)
		-> email등은 throughput보다 데이터가 오류없이 전송되는것이 더 중요하다
	-> Timing : 시간차
		-> throughput은 일부 시간차가 있더라도 많은 양의 데이터가 빠르게 전달이지만
		-> 타이밍은 반응속도가 중요함 (ex. 실시간 FPS게임, 전화 등)

	응용서비스가 무엇이냐에 따라 위 세가지 서비스의 중요도가 달라질 수 있다.


------------------------------------------------------------------------------------------------
p. 13

인터넷 전송 프로토콜 서비스

	TCP
		-> 오류가 없음, 병목현상, 타이밍 기능x, 최저속도 보장x, 보안x, 
		-> 연결 지향형 (가상의 파이프를 만듬) : 

	UDP
		-> 로스, 오류가 발생할 수 있음
		-> 연결셋업없고, 속도조절 없음, 기능이 단순하고 동작속도가 빠름


	왜 둘다있는가? 서로 목적에 따라 쓰임이 다르기때문


------------------------------------------------------------------------------------------------
p. 15

Securing TCP

TCP & UDP에는 기본적으로 보안이없으므로 이를 보완하기 위해 개발된것
	-> 패킷에는 clear text로 전송됨

	SSL : 암호화기능(encryption)을 추가한것 (Secure Socket Layer)
		-> 데이터 무결성을 가짐, 양단에서 인증을 거침
		-> SSL은 응용계층에 있음


------------------------------------------------------------------------------------------------
p. 16

응용계층에서의 프로토콜중 하나인 HTTP에 대해 알아보자

	-> 웹페이지는 다수의 object로 구성되어있다
		-> object에는 HTML, JPEG 등 여러가지가 있다.
		-> 기본은 HTML임 (Hypertext Markup Language), 어떤 object도 base-HTML이 필요!
		-> base-HTML은 object들의 reference를 포함한다
			-> 레퍼런스는 URL형식으로 되어있다.



------------------------------------------------------------------------------------------------
p. 17

HTTP는 어떻게 동작하는가???

	-> 클라이언트/서버 모델을 따른다
	-> 클라이언트는 브라우저, 서버는 웹 서버이다.
		-> 웹서버에서 request를 받아 client에 보내고, 이를 client가 받아 display한다

	-> HTTP는 public domain protocol이다
	
	-> 여러 client가 server에 HTTP request를 보내면
		-> server는 client에 HTTP response를 보냄


------------------------------------------------------------------------------------------------
p. 18

HTTP는 TCP를 사용한다!

	-> client가 TCP를 사용하려면 먼저 TCP port를 셋업해야함 (TCP connection 요청)
	-> 서버가 이를 받아들이면 커넥션이 만들어짐
	-> HTTP 메시지들이 교환됨
	-> 작업이 모두 끝나면 TCP 커넥션이 해제가 됨

	-> HTTP는 상태정보를 유지,관리하는 프로토콜이 아니다! (stateless)
		-> 프로토콜이 state를 포함하려면 매우 복잡해짐 (과거의 상태를 저장, 상태 불일치의 문제)

------------------------------------------------------------------------------------------------
p. 19

Non-persistent HTTP
	-> TCP 커넥션이 지속적으로 사용되지 않음
	-> 커넥션을 이으면 오브젝트를 최대 1개만 전송하고 커넥션을 해제함
	-> 일정 오브젝트의 갯수만큼만 커넥션을 설정,해제해야해서 효율적이지 않다!
	-> HTTP 1.0의 방식이다.

Persistent HTTP

	-> 커넥션을 한번 설정하면 여러 오브젝트를 전송할 수 있음
	-> HTTP 1.1의 방식이다.


------------------------------------------------------------------------------------------------
p. 20

Non-Persistent HTTP의 동작방식

	-> 유저가 URL을 브라우저에 입력했다.
	1. HTTP client가 TCP connection을 HTTP server에 요청한다 (요청 메시지가 있음)
	2. HTTP가 이 커넥션을 설정할 지 내부적으로 검토함 (설정할 자원이 있는지 확인 등)
	3. 응답 메시지를 HTTP client에 보낸다
	4. HTTP client가 HTTP server에 request message를 보낸다 (URL을 이제야 전송함)
	5. HTTP server가 수신을 하면 response message를 전송(object가 담겨있음 (base-HTML))
	6. HTTP client가 response를 받고나면 server가 TCP connection을 해제한다
	7. HTTP client는 HTML을 화면에 display한다
	8~ base object이후에 필요한 object 수만큼 위의 과정을 반복하며 object를 하나씩 받아온다


------------------------------------------------------------------------------------------------
p. 22

RTT : Round Trip Time의 약자로, 메시지가 서버까지 갔다가 다시 오는데 걸리는 시간

	-> TCP connection 메시지를 server에서 처리하는데는 매우 빠름!
	-> HTTP response, request를 받아 처리하는데는 일정 시간이 필요할 수 있음!

	-> 전체 시간 : 2RTT + transmit time

------------------------------------------------------------------------------------------------
p. 23

처음에는 base HTML 오브젝트를 받고

	이후에는 만약 10개의 object가 필요하다고 하면 다시 10번의 과정을 반복함
	-> 총 11번의 과정

	embedded object : reference object와 같은 의미
			-> base-HTML에 적힌 object들	

------------------------------------------------------------------------------------------------
p. 24

Persistent HTTP의 동작방식

	-> 이전의 non-persistent는 오브젝트마다 2RTT의 시간이 필요했다
		-> 또, TCP커넥션마다 OS의 overhead가 있다.
		-> 레퍼런스 오브젝트에 대해서는 병렬적으로 TCP커넥션을 열수 있다.

	-> Non-persistent에서의 TCP connection은 overhead를 가져옴
	-> 이를 개선한것이 Persistent이다!

------------------------------------------------------------------------------------------------
p. 25

처음에 TCP connection에 RTT1번
	, base HTML에 RTT 1번
	, 2개의 object에 RTT 2번의 시간이 든다


	Persistent는 overhead를 줄여주고 Connection setup의 딜레이는 줄여주지만
	-> non-persistent에서는 병렬처리가 가능하기 때문에
	-> 어떤 경우에는 persistent가 어떤 경우에는 non-persistent가 효율적이다.

	-> Persistent에서는 non-persistent에서처럼 병렬이 되지 않는다.


------------------------------------------------------------------------------------------------
p. 26

HTTP message

	-> request와 response가 있다.
	-> request message는 아스키코드값이다




------------------------------------------------------------------------------------------------
p. 28

POST method
	-> URL을 요청하는 경우의 메시지에 사용
	-> 서버에 input을 entity body에 넣어 올린다
		-> URL이 input을 요구할때 input을 같이 올리는것

GET method
	-> HTML이나 오브젝트를 받는 메시지에 사용
	-> 


------------------------------------------------------------------------------------------------
p. 28


	PUT은 URL이 input을 요구하지 않아도 같이 input을 올리는것
		-> 보통은 잘 허용, 사용하지 않음

	DELETE : 웹 서버에 있는 파일을 delete하고 싶을 때 사용
		-> 원격에서 device에 접속해서 설정, 셋업할때 주로 사용


------------------------------------------------------------------------------------------------
p. 30

지금까지 HTTP request message에 대해 설명했고
이제 HTTP response message에 대해 알아보자

이전과 다르게 가장 첫줄에 request line이 아니라 status line이 있다





------------------------------------------------------------------------------------------------
p. 31, 32

status code의 종류

HTTP를 직접 수행해 볼 수 있다.



------------------------------------------------------------------------------------------------
p. 33

쿠키

User-server state : cookies

	-> 쿠키는 4가지 구성요소를 가진다
	-> HTTP request와 response에도 쿠키헤더라인이 있을 수 있다.
		-> 위의 강의자료예시엔 없음
	-> User의 host에 쿠키파일이 저장됨 (브라우저의 디렉토리 어딘가)
	-> 웹서버쪽의 db에 쿠키관련 정보가 저장됨

	ex.) 수잔이 항상 같은 PC로 접속을 한다
		-> 인터넷 쇼핑사이트에 처음 접속을하면
		-> 첫 HTTP request를 보낼때는 쿠키가 안실려가고
		-> 쿠키가 없다면 서버가 ID를 하나만들고, 백엔드 db에 ID에관한 기본정보를 저장
			-> 그리고 쿠키 번호를 하나 저장함 
		-> 이를 HTTP response message에 실어보냄

------------------------------------------------------------------------------------------------
p. 34

첫 request에는 쿠키가 없고 서버가 이를 받아 user의 ID를 만들어 
	response로 보냄
	-> 이후에 다시 request를 보내면 이 때 1678이라는 쿠키가 실려감
	-> 서버에서 1678 ID에 최적화된 내용을 보냄
		-> db에 해당ID에 연관된 내용이 저장되어있음






------------------------------------------------------------------------------------------------
p. 35

쿠키는 어디에 쓰이는가

	-> 사용자 인증
	-> 장바구니
	-> 사용자 추천
	-> 웹메일등을 어디까지 읽었는지등의 정보

쿠키는 PC에 저장되는것이기 때문에 PC를 옮기면 효과가 없다
	-> 보안을 위해서는 쿠키를 삭제하는것이 좋다

------------------------------------------------------------------------------------------------
p. 36

Proxy server

	-> 프록시를 사용하지 않는다면 request를 바로 서버로 보낸다
	-> 프록시서버가 있다면 request를 프록시서버로 보낸다
	-> Proxy Server가 Origin server를 대신하지만 완벽하지는 않음

	-> 만약 Proxy server가 request에 해당하는 자료를 가지고 있다면
	-> 프록시가 response를 보내지만 없다면 request를 Origin으로 다시보냄


------------------------------------------------------------------------------------------------
p. 37

웹 캐시는 왜쓰나?

	-> response time을 줄이기 위해
		-> request가 origin server까지 안가고 금방 response가 옴
	-> 운영기관입장에서는 트래픽을 줄일 수 있다.
	-> 경제적이다.


------------------------------------------------------------------------------------------------
p. 38
		*** 중간고사 출제 ***
Caching example

가정)
	평균 오브젝트크기 : 10만 비트
	기관에서 origin server로의 request rate : 15 오브젝트/sec
	edge router : 코어네트워크의 가장 바깥쪽의 라우터
	edge router에서 origin까지 갔다오는 시간 : 2 sec

	-> 1초에 10만 bit의 오브젝트를 15번 request를 보낸다
		-> 1500000 bps (15만)
	-> 기관네트워크는 10000000 bps 이므로 (100만)
	-> LAN 안에서의 utilization은 15%가 된다
	-> 반면 access link에서는 utilization이 100%가 된다.

	-> Institute에서는 들어오는양이 내보내는양의 15%밖에 안되므로
	-> LAN내부의 딜레이는 매우 작다 (밀리세컨드)
	-> access에서는 100%이므로 그래프에 따라 딜레이가 매우 크다(분 단위)

	-> 다 합치면 2초 + 분 + 밀리초
		-> access link에서 딜레이가 너무 크다!!
		-> 해결해야함!!

------------------------------------------------------------------------------------------------
p. 39

access link의 bandwidth를 10Mbps 로 늘리면 되지 않나??

	-> access와 LAN모두 딜레이가 밀리세턴드가 되지만
	-> 가격이 개비싸짐 ㄷㄷ
	-> 그럼 어캄??

------------------------------------------------------------------------------------------------
p. 40
		*** 중간고사 출제 ***
캐시를 사용하자!!

	-> Hit rate 가 4라고 해보자 (40%)
	-> 40%의 request는 내부적으로 즉시 처리됨
	-> 60%의 request가 access link를 타고 감
	
	-> 이러면 원래 access link에서의 delay가 40% 감소하는 효과!
	-> 전체 딜레이 : 0.6 * (2sec + access delay) + 1.4 * LAN delay

	-> 전보다는 훠어얼씬 나아졌다
	-> 서버 하나 가져다 놓는거는 전의 방법보다 훨씬 경제적이다!!!

------------------------------------------------------------------------------------------------
p. 41

Conditional GET

	-> request가 Proxy에 도달해서 정보를 전달하는데
	-> 너무 오래된 정보는 전달하면 안된다!
	-> 프록시에 있는 정보가 최신의 정보인지 확인할 필요가 있다.

	-> 304 는 에러메시지가 아니라 최신의 정보가 아니다 라는것뿐임!


------------------------------------------------------------------------------------------------
p. 43









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









