p. 2

이번장에서는 응용계층에 대해 설명한다





------------------------------------------------------------------------------------------------
p. 4

네트워크앱은 2가지로 나뉘어 만들어져야한다.

	-> 네트워크 코어에서는 패킷을 전달하는것 말고는 다른기능이 없다
	-> 브라우저와 웹서버에서 프로그램의 대부분을 차지



------------------------------------------------------------------------------------------------
p. 5

서버
	-> 호스트, 고정 IP, 물리적 서버를 여러개 운영함(서버가 복제된 형태)

클라이언트
	-> 서버와 통신, IP가 바뀔수있음
	-> 클라이언트끼리 통신하지 않음



------------------------------------------------------------------------------------------------
p. 7

프로세스간의 통신

	프로세스 : 호스트에서 수행되는 중인 프로그램
	inter-process communication : 같은 호스트 안에서도 프로세스끼리 통신을 할 수 있다
	message exchange : 서로 다른 호스트에서의 프로세스끼리의 통신

	P2P는 클라이언트 기능과 서버기능 모두 탑재를 해야한다

------------------------------------------------------------------------------------------------
p. 8

소켓

프로세스는 소켓을 통해 메시지를 전송하고 받는다
	-> 소켓에 연결된 데이터는 알아서 이어진 소켓으로 전송된다

	API
	-> transport 프로토콜을 선택하는 함수 (TCP, UDP 등)
	-> 몇몇 파라미터를 설정하는 함수

	순서)
	1. 응용 프로세스에서 소켓의 함수를 호출함
	2. 소켓을 통해 메시지가 전달됨 (TCP는 OS에 탑재됨)
	3. 인터넷을따라 소켓을 통해 상대방에게 전달됨


------------------------------------------------------------------------------------------------
p. 9

Addressing Process

	-> 호스트는 자기자신만의 32bit IP주소를 가지고 있다.
		-> 그러나 주소만 가지고 있으면 안된다!
		-> 인터넷을 따라 오는건 IP주소 하나면 되지만
		-> 어떤 프로세스에 전달할지는 port number에 따라 정해진다

	Port number : 호스트의 프로세스와 관련!
	well-known port number : 인터넷 표준으로 정해진 포트넘버가 있음

	메시지를 교환하기 위해선 IP주소와 port넘버가 필요하다


------------------------------------------------------------------------------------------------
p. 10

App Layer의 프로토콜

	-> 메시지를 정의한다
		-> 메시지의 종류와 메시지의 필드를 정의함
		-> 언제 어떤 메시지를 전송하고 교환하는지, 응답으로는 어떤 메시지를 전달하는지
	Public domain protocols 
		-> RFC문서에 정의됨, 연동에 주안점을 둠, HTTP, SMTP (공익적인 목적에 초점을 둠)
	Proprietary protocols
		-> 기업이 이윤을 추구하기 위해 만듬, Skype

------------------------------------------------------------------------------------------------
p. 11

응용계층에서의 Transport service는 무엇을 할까???

	-> 응용계층은 transport 계층의 기능을 가져다 씀
	-> Data Integrity : 데이터의 전송에 오류가 있어도 되는지 아닌지 (데이터의 무결성)
		-> TCP는 오류가 발생하지 않는 서비스임(발생해도 다 복구해줌)
		-> ex.) 오디오는 오류가 조금 있어도됨 , 은행서비스는 오류가 있으면 안됨!
	-> Throughput : 전송속도
		-> 일부 app은 약간의 오류가 있어도 throughput이 더 중요하다 (스트리밍 등)
		-> email등은 throughput보다 데이터가 오류없이 전송되는것이 더 중요하다
	-> Timing : 시간차
		-> throughput은 일부 시간차가 있더라도 많은 양의 데이터가 빠르게 전달이지만
		-> 타이밍은 반응속도가 중요함 (ex. 실시간 FPS게임, 전화 등)

	응용서비스가 무엇이냐에 따라 위 세가지 서비스의 중요도가 달라질 수 있다.


------------------------------------------------------------------------------------------------
p. 13

인터넷 전송 프로토콜 서비스

	TCP
		-> 오류가 없음, 병목현상, 타이밍 기능x, 최저속도 보장x, 보안x, 
		-> 연결 지향형 (가상의 파이프를 만듬) : 

	UDP
		-> 로스, 오류가 발생할 수 있음
		-> 연결셋업없고, 속도조절 없음, 기능이 단순하고 동작속도가 빠름


	왜 둘다있는가? 서로 목적에 따라 쓰임이 다르기때문


------------------------------------------------------------------------------------------------
p. 15

Securing TCP

TCP & UDP에는 기본적으로 보안이없으므로 이를 보완하기 위해 개발된것
	-> 패킷에는 clear text로 전송됨

	SSL : 암호화기능(encryption)을 추가한것 (Secure Socket Layer)
		-> 데이터 무결성을 가짐, 양단에서 인증을 거침
		-> SSL은 응용계층에 있음


------------------------------------------------------------------------------------------------
p. 16

응용계층에서의 프로토콜중 하나인 HTTP에 대해 알아보자

	-> 웹페이지는 다수의 object로 구성되어있다
		-> object에는 HTML, JPEG 등 여러가지가 있다.
		-> 기본은 HTML임 (Hypertext Markup Language), 어떤 object도 base-HTML이 필요!
		-> base-HTML은 object들의 reference를 포함한다
			-> 레퍼런스는 URL형식으로 되어있다.



------------------------------------------------------------------------------------------------
p. 17

HTTP는 어떻게 동작하는가???

	-> 클라이언트/서버 모델을 따른다
	-> 클라이언트는 브라우저, 서버는 웹 서버이다.
		-> 웹서버에서 request를 받아 client에 보내고, 이를 client가 받아 display한다

	-> HTTP는 public domain protocol이다
	
	-> 여러 client가 server에 HTTP request를 보내면
		-> server는 client에 HTTP response를 보냄


------------------------------------------------------------------------------------------------
p. 18

HTTP는 TCP를 사용한다!

	-> client가 TCP를 사용하려면 먼저 TCP port를 셋업해야함 (TCP connection 요청)
	-> 서버가 이를 받아들이면 커넥션이 만들어짐
	-> HTTP 메시지들이 교환됨
	-> 작업이 모두 끝나면 TCP 커넥션이 해제가 됨

	-> HTTP는 상태정보를 유지,관리하는 프로토콜이 아니다! (stateless)
		-> 프로토콜이 state를 포함하려면 매우 복잡해짐 (과거의 상태를 저장, 상태 불일치의 문제)

------------------------------------------------------------------------------------------------
p. 19

Non-persistent HTTP
	-> TCP 커넥션이 지속적으로 사용되지 않음
	-> 커넥션을 이으면 오브젝트를 최대 1개만 전송하고 커넥션을 해제함
	-> 일정 오브젝트의 갯수만큼만 커넥션을 설정,해제해야해서 효율적이지 않다!
	-> HTTP 1.0의 방식이다.

Persistent HTTP

	-> 커넥션을 한번 설정하면 여러 오브젝트를 전송할 수 있음
	-> HTTP 1.1의 방식이다.


------------------------------------------------------------------------------------------------
p. 20

Non-Persistent HTTP의 동작방식

	-> 유저가 URL을 브라우저에 입력했다.
	1. HTTP client가 TCP connection을 HTTP server에 요청한다 (요청 메시지가 있음)
	2. HTTP가 이 커넥션을 설정할 지 내부적으로 검토함 (설정할 자원이 있는지 확인 등)
	3. 응답 메시지를 HTTP client에 보낸다
	4. HTTP client가 HTTP server에 request message를 보낸다 (URL을 이제야 전송함)
	5. HTTP server가 수신을 하면 response message를 전송(object가 담겨있음 (base-HTML))
	6. HTTP client가 response를 받고나면 server가 TCP connection을 해제한다
	7. HTTP client는 HTML을 화면에 display한다
	8~ base object이후에 필요한 object 수만큼 위의 과정을 반복하며 object를 하나씩 받아온다


------------------------------------------------------------------------------------------------
p. 22

RTT : Round Trip Time의 약자로, 메시지가 서버까지 갔다가 다시 오는데 걸리는 시간

	-> TCP connection 메시지를 server에서 처리하는데는 매우 빠름!
	-> HTTP response, request를 받아 처리하는데는 일정 시간이 필요할 수 있음!

	-> 전체 시간 : 2RTT + transmit time

------------------------------------------------------------------------------------------------
p. 23

처음에는 base HTML 오브젝트를 받고

	이후에는 만약 10개의 object가 필요하다고 하면 다시 10번의 과정을 반복함
	-> 총 11번의 과정

	embedded object : reference object와 같은 의미
			-> base-HTML에 적힌 object들	

------------------------------------------------------------------------------------------------
p. 24

Persistent HTTP의 동작방식

	-> 이전의 non-persistent는 오브젝트마다 2RTT의 시간이 필요했다
		-> 또, TCP커넥션마다 OS의 overhead가 있다.
		-> 레퍼런스 오브젝트에 대해서는 병렬적으로 TCP커넥션을 열수 있다.

	-> Non-persistent에서의 TCP connection은 overhead를 가져옴
	-> 이를 개선한것이 Persistent이다!

------------------------------------------------------------------------------------------------
p. 25

처음에 TCP connection에 RTT1번
	, base HTML에 RTT 1번
	, 2개의 object에 RTT 2번의 시간이 든다


	Persistent는 overhead를 줄여주고 Connection setup의 딜레이는 줄여주지만
	-> non-persistent에서는 병렬처리가 가능하기 때문에
	-> 어떤 경우에는 persistent가 어떤 경우에는 non-persistent가 효율적이다.

	-> Persistent에서는 non-persistent에서처럼 병렬이 되지 않는다.


------------------------------------------------------------------------------------------------
p. 26

HTTP message

	-> request와 response가 있다.
	-> request message는 아스키코드값이다




------------------------------------------------------------------------------------------------
p. 28

POST method
	-> URL을 요청하는 경우의 메시지에 사용
	-> 서버에 input을 entity body에 넣어 올린다
		-> URL이 input을 요구할때 input을 같이 올리는것

GET method
	-> HTML이나 오브젝트를 받는 메시지에 사용
	-> 


------------------------------------------------------------------------------------------------
p. 28


	PUT은 URL이 input을 요구하지 않아도 같이 input을 올리는것
		-> 보통은 잘 허용, 사용하지 않음

	DELETE : 웹 서버에 있는 파일을 delete하고 싶을 때 사용
		-> 원격에서 device에 접속해서 설정, 셋업할때 주로 사용


------------------------------------------------------------------------------------------------
p. 30

지금까지 HTTP request message에 대해 설명했고
이제 HTTP response message에 대해 알아보자

이전과 다르게 가장 첫줄에 request line이 아니라 status line이 있다





------------------------------------------------------------------------------------------------
p. 31, 32

status code의 종류

HTTP를 직접 수행해 볼 수 있다.



------------------------------------------------------------------------------------------------
p. 33

쿠키

User-server state : cookies

	-> 쿠키는 4가지 구성요소를 가진다
	-> HTTP request와 response에도 쿠키헤더라인이 있을 수 있다.
		-> 위의 강의자료예시엔 없음
	-> User의 host에 쿠키파일이 저장됨 (브라우저의 디렉토리 어딘가)
	-> 웹서버쪽의 db에 쿠키관련 정보가 저장됨

	ex.) 수잔이 항상 같은 PC로 접속을 한다
		-> 인터넷 쇼핑사이트에 처음 접속을하면
		-> 첫 HTTP request를 보낼때는 쿠키가 안실려가고
		-> 쿠키가 없다면 서버가 ID를 하나만들고, 백엔드 db에 ID에관한 기본정보를 저장
			-> 그리고 쿠키 번호를 하나 저장함 
		-> 이를 HTTP response message에 실어보냄

------------------------------------------------------------------------------------------------
p. 34

첫 request에는 쿠키가 없고 서버가 이를 받아 user의 ID를 만들어 
	response로 보냄
	-> 이후에 다시 request를 보내면 이 때 1678이라는 쿠키가 실려감
	-> 서버에서 1678 ID에 최적화된 내용을 보냄
		-> db에 해당ID에 연관된 내용이 저장되어있음






------------------------------------------------------------------------------------------------
p. 35

쿠키는 어디에 쓰이는가

	-> 사용자 인증
	-> 장바구니
	-> 사용자 추천
	-> 웹메일등을 어디까지 읽었는지등의 정보

쿠키는 PC에 저장되는것이기 때문에 PC를 옮기면 효과가 없다
	-> 보안을 위해서는 쿠키를 삭제하는것이 좋다

------------------------------------------------------------------------------------------------
p. 36

Proxy server

	-> 프록시를 사용하지 않는다면 request를 바로 서버로 보낸다
	-> 프록시서버가 있다면 request를 프록시서버로 보낸다
	-> Proxy Server가 Origin server를 대신하지만 완벽하지는 않음

	-> 만약 Proxy server가 request에 해당하는 자료를 가지고 있다면
	-> 프록시가 response를 보내지만 없다면 request를 Origin으로 다시보냄


------------------------------------------------------------------------------------------------
p. 37

웹 캐시는 왜쓰나?

	-> response time을 줄이기 위해
		-> request가 origin server까지 안가고 금방 response가 옴
	-> 운영기관입장에서는 트래픽을 줄일 수 있다.
	-> 경제적이다.


------------------------------------------------------------------------------------------------
p. 38
		*** 중간고사 출제 ***
Caching example

가정)
	평균 오브젝트크기 : 10만 비트
	기관에서 origin server로의 request rate : 15 오브젝트/sec
	edge router : 코어네트워크의 가장 바깥쪽의 라우터
	edge router에서 origin까지 갔다오는 시간 : 2 sec

	-> 1초에 10만 bit의 오브젝트를 15번 request를 보낸다
		-> 1500000 bps (15만)
	-> 기관네트워크는 10000000 bps 이므로 (100만)
	-> LAN 안에서의 utilization은 15%가 된다
	-> 반면 access link에서는 utilization이 100%가 된다.

	-> Institute에서는 들어오는양이 내보내는양의 15%밖에 안되므로
	-> LAN내부의 딜레이는 매우 작다 (밀리세컨드)
	-> access에서는 100%이므로 그래프에 따라 딜레이가 매우 크다(분 단위)

	-> 다 합치면 2초 + 분 + 밀리초
		-> access link에서 딜레이가 너무 크다!!
		-> 해결해야함!!

------------------------------------------------------------------------------------------------
p. 39

access link의 bandwidth를 10Mbps 로 늘리면 되지 않나??

	-> access와 LAN모두 딜레이가 밀리세턴드가 되지만
	-> 가격이 개비싸짐 ㄷㄷ
	-> 그럼 어캄??

------------------------------------------------------------------------------------------------
p. 40
		*** 중간고사 출제 ***
캐시를 사용하자!!

	-> Hit rate 가 4라고 해보자 (40%)
	-> 40%의 request는 내부적으로 즉시 처리됨
	-> 60%의 request가 access link를 타고 감
	
	-> 이러면 원래 access link에서의 delay가 40% 감소하는 효과!
	-> 전체 딜레이 : 0.6 * (2sec + access delay) + 1.4 * LAN delay

	-> 전보다는 훠어얼씬 나아졌다
	-> 서버 하나 가져다 놓는거는 전의 방법보다 훨씬 경제적이다!!!

------------------------------------------------------------------------------------------------
p. 41

Conditional GET

	-> request가 Proxy에 도달해서 정보를 전달하는데
	-> 너무 오래된 정보는 전달하면 안된다!
	-> 프록시에 있는 정보가 최신의 정보인지 확인할 필요가 있다.

	-> 304 는 에러메시지가 아니라 최신의 정보가 아니다 라는것뿐임!


------------------------------------------------------------------------------------------------
p. 43









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 54

DNS : Domain Name System

	-> 전세계의 모든 호스트의 IP주소를 담당함
		-> 분산처리 방식, 서버 여러대가 운영
		-> 각각의 데이터베이스를 가짐
	-> 각 서버를 Name 서버라고 하고, 서로 통신을 하는데
		-> 이 프로토콜은 App Layer의 프로토콜임!!!
		-> 인터넷의 복잡한 많은 기능을 Host에서 (edge)처리하도록해서 운영을 단순화하는 장점!
		-> 이름을 변환하는 과정 (Resove)
	-> 인터넷에서 호스트 네임을 사용해서 통신을 하려면 필수적이다!


DNS 는 Host name을 IP address로 변환한다!!!

	-> Host aliasing : 호스트에 별칭을 붙인다!
		-> 여러대의 서버네임을 하나의 별칭으로 쓸 수 있게함!
	-> Mail server aliasing : 메일 서버도 마찬가지
	-> Load distribution
		-> 별칭을 통해 들어온 요청을 서버에 잘 분산해서 처리!

왜 DNS를 중앙처리방식이 아닌 분산방식으로 만들었나?

	-> 중앙처리일때 서버 한대가 다운되면 인터넷 전체가 다운되게됨!
		-> 이를 방지하기 위해
	-> 트래픽이 한데에 몰리지 않게함
	-> 중앙집중방식은 물리적거리에서 오는 단점이있다
	-> 확장성이 좋지 않다!!!


------------------------------------------------------------------------------------------------
p. 56

DNS는 분산처리 방식이지만, 계층구조를 가진다.

	-> 가장 위에 Root가 있고, 그 밑에 최상위 Domain server가 있다.
	-> 다시 그 밑에 각 기업들만의 DNS서버도 있다. (ex. .kr 같은것)

	-> 클라이언트가 www.amazon.com의 IP주소를 원한다 하면
		-> root DNS가 .com DNS의 주소를 얻고
		-> amazon.com의 DNS주소를 얻는다
		-> root -> 닷컴 -> 아마존 식의 순서로 위에서부터 아래계층으로 request가 내려온다



------------------------------------------------------------------------------------------------
p. 57

사실 Root DNS 는 총 13개의 root DNS서버가 분산을 하고있다!!

	-> 실제 호스트에서 IP로의 변환 정보는 최 하위 DNS (네임서버)에 존재한다!
	-> 루트는 어떻게 최 하위까지 어떻게 찾아가는지에 대한 정보가 있다.



------------------------------------------------------------------------------------------------
p. 58

TLD : Top Level Domain

	-> 전통적인 탑레벨 도메인의 네트워크 서버는 네트워크 솔루션이라는 비영리 기업이 운영
		-> 닷컴은 네트워크솔루션, edu는 에듀커스

	-> 더 하위로 가면, 개별 기관및 학교가 DNS을 운영
		-> Authoritative DNS server
		-> .ex 광운대 : 광운대 정보통신처에서 운영
		-> 여기서 IP주소로 매핑정보가 저장


------------------------------------------------------------------------------------------------
p. 59

Local Name Server

	-> 호스트나 클라이언트가, 주소변환 요청을 보낼때
	-> 디폴트 : 요청은 로컬네임서버에 도착

	-> Authoritative DNS server와 같을 수 있지만, 같지는 않다
	-> ??? 더 찾아보기



------------------------------------------------------------------------------------------------
p. 60

이 예제는 Iterative 방식 (반복적인 방식)

사용자가 호스트네임을 입력했다.
	-> 이를 IP로 변환해야함
	-> Local DNS에도 변환정보가 일정기간동안은 저장되어있음!
	-> 저장되어있지 않다면 변환요청이 root로 감
	-> 루트가 edu변환이 어디에있는지 정보를 보냄
	-> Local은 TLD로 보내고, 다시 기관의 정보를 보냄
	-> 다시 Authoritative DNS server로 요청을 보내면
	-> 최종 변환된 IP address를 보냄

Wire shark에서의 문제는 1~7의 과정을 거치지 않고, 바로 Authoritative DNS server에 변환요청을 해봐라 였음
	-> 안될 수도 있다.

------------------------------------------------------------------------------------------------
p. 61

Recursive 방식

	-> 앞에서의 Local이 계속 해서 반복작업을 하는 방식은 Local에 부하가 걸릴 수 있음
		-> 이를 방지하기 위한 방식
	-> 로컬->루트->TLD->Author->(IP 변환!)->TLD->루트->로컬 -> 호스트에 도착!


------------------------------------------------------------------------------------------------
p. 62

DNS는 캐싱을 사용한다!

	-> 앞서 변환정보를 받아오면 일정 시간동안 정보를 캐시에 저장한다.
		-> timeout이 되면 저장된 정보를 삭제한다
	-> TLD server에 캐시가 있음! 
		


------------------------------------------------------------------------------------------------
p. 63

RR : Resource record

	-> 어떤 서비스를 제공하느냐에 따라 Type이 달라짐
	A : 호스트이름과 아이피 주소
	NS : 
	CNAME : 
	NX : 
		-> 강의듣고 이해x 따로 찾아볼것

------------------------------------------------------------------------------------------------
p. 64

쿼리, reply메시지는 동일함 : 같은 메시지 포맷

	플래그에 따라 쿼리인지 리플라이인지 등의 정보가 갈림
	




------------------------------------------------------------------------------------------------
p. 65









------------------------------------------------------------------------------------------------
p. 66

DNS 서버에 record는 누가 넣어주나

	-> 





------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









