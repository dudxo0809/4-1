p. 2

이번장에서는 응용계층에 대해 설명한다





------------------------------------------------------------------------------------------------
p. 4

네트워크앱은 2가지로 나뉘어 만들어져야한다.

	-> 네트워크 코어에서는 패킷을 전달하는것 말고는 다른기능이 없다
	-> 브라우저와 웹서버에서 프로그램의 대부분을 차지



------------------------------------------------------------------------------------------------
p. 5

서버
	-> 호스트, 고정 IP, 물리적 서버를 여러개 운영함(서버가 복제된 형태)

클라이언트
	-> 서버와 통신, IP가 바뀔수있음
	-> 클라이언트끼리 통신하지 않음



------------------------------------------------------------------------------------------------
p. 7

프로세스간의 통신

	프로세스 : 호스트에서 수행되는 중인 프로그램
	inter-process communication : 같은 호스트 안에서도 프로세스끼리 통신을 할 수 있다
	message exchange : 서로 다른 호스트에서의 프로세스끼리의 통신

	P2P는 클라이언트 기능과 서버기능 모두 탑재를 해야한다

------------------------------------------------------------------------------------------------
p. 8

소켓

프로세스는 소켓을 통해 메시지를 전송하고 받는다
	-> 소켓에 연결된 데이터는 알아서 이어진 소켓으로 전송된다

	API
	-> transport 프로토콜을 선택하는 함수 (TCP, UDP 등)
	-> 몇몇 파라미터를 설정하는 함수

	순서)
	1. 응용 프로세스에서 소켓의 함수를 호출함
	2. 소켓을 통해 메시지가 전달됨 (TCP는 OS에 탑재됨)
	3. 인터넷을따라 소켓을 통해 상대방에게 전달됨


------------------------------------------------------------------------------------------------
p. 9

Addressing Process

	-> 호스트는 자기자신만의 32bit IP주소를 가지고 있다.
		-> 그러나 주소만 가지고 있으면 안된다!
		-> 인터넷을 따라 오는건 IP주소 하나면 되지만
		-> 어떤 프로세스에 전달할지는 port number에 따라 정해진다

	Port number : 호스트의 프로세스와 관련!
	well-known port number : 인터넷 표준으로 정해진 포트넘버가 있음

	메시지를 교환하기 위해선 IP주소와 port넘버가 필요하다


------------------------------------------------------------------------------------------------
p. 10

App Layer의 프로토콜

	-> 메시지를 정의한다
		-> 메시지의 종류와 메시지의 필드를 정의함
		-> 언제 어떤 메시지를 전송하고 교환하는지, 응답으로는 어떤 메시지를 전달하는지
	Public domain protocols 
		-> RFC문서에 정의됨, 연동에 주안점을 둠, HTTP, SMTP (공익적인 목적에 초점을 둠)
	Proprietary protocols
		-> 기업이 이윤을 추구하기 위해 만듬, Skype

------------------------------------------------------------------------------------------------
p. 11

응용계층에서의 Transport service는 무엇을 할까???

	-> 응용계층은 transport 계층의 기능을 가져다 씀
	-> Data Integrity : 데이터의 전송에 오류가 있어도 되는지 아닌지 (데이터의 무결성)
		-> TCP는 오류가 발생하지 않는 서비스임(발생해도 다 복구해줌)
		-> ex.) 오디오는 오류가 조금 있어도됨 , 은행서비스는 오류가 있으면 안됨!
	-> Throughput : 전송속도
		-> 일부 app은 약간의 오류가 있어도 throughput이 더 중요하다 (스트리밍 등)
		-> email등은 throughput보다 데이터가 오류없이 전송되는것이 더 중요하다
	-> Timing : 시간차
		-> throughput은 일부 시간차가 있더라도 많은 양의 데이터가 빠르게 전달이지만
		-> 타이밍은 반응속도가 중요함 (ex. 실시간 FPS게임, 전화 등)

	응용서비스가 무엇이냐에 따라 위 세가지 서비스의 중요도가 달라질 수 있다.


------------------------------------------------------------------------------------------------
p. 13

인터넷 전송 프로토콜 서비스

	TCP
		-> 오류가 없음, 병목현상, 타이밍 기능x, 최저속도 보장x, 보안x, 
		-> 연결 지향형 (가상의 파이프를 만듬) : 

	UDP
		-> 로스, 오류가 발생할 수 있음
		-> 연결셋업없고, 속도조절 없음, 기능이 단순하고 동작속도가 빠름


	왜 둘다있는가? 서로 목적에 따라 쓰임이 다르기때문


------------------------------------------------------------------------------------------------
p. 15

Securing TCP

TCP & UDP에는 기본적으로 보안이없으므로 이를 보완하기 위해 개발된것
	-> 패킷에는 clear text로 전송됨

	SSL : 암호화기능(encryption)을 추가한것 (Secure Socket Layer)
		-> 데이터 무결성을 가짐, 양단에서 인증을 거침
		-> SSL은 응용계층에 있음


------------------------------------------------------------------------------------------------
p. 16

응용계층에서의 프로토콜중 하나인 HTTP에 대해 알아보자

	-> 웹페이지는 다수의 object로 구성되어있다
		-> object에는 HTML, JPEG 등 여러가지가 있다.
		-> 기본은 HTML임 (Hypertext Markup Language), 어떤 object도 base-HTML이 필요!
		-> base-HTML은 object들의 reference를 포함한다
			-> 레퍼런스는 URL형식으로 되어있다.



------------------------------------------------------------------------------------------------
p. 17

HTTP는 어떻게 동작하는가???

	-> 클라이언트/서버 모델을 따른다
	-> 클라이언트는 브라우저, 서버는 웹 서버이다.
		-> 웹서버에서 request를 받아 client에 보내고, 이를 client가 받아 display한다

	-> HTTP는 public domain protocol이다
	
	-> 여러 client가 server에 HTTP request를 보내면
		-> server는 client에 HTTP response를 보냄


------------------------------------------------------------------------------------------------
p. 18

HTTP는 TCP를 사용한다!

	-> client가 TCP를 사용하려면 먼저 TCP port를 셋업해야함 (TCP connection 요청)
	-> 서버가 이를 받아들이면 커넥션이 만들어짐
	-> HTTP 메시지들이 교환됨
	-> 작업이 모두 끝나면 TCP 커넥션이 해제가 됨

	-> HTTP는 상태정보를 유지,관리하는 프로토콜이 아니다! (stateless)
		-> 프로토콜이 state를 포함하려면 매우 복잡해짐 (과거의 상태를 저장, 상태 불일치의 문제)

------------------------------------------------------------------------------------------------
p. 19

Non-persistent HTTP
	-> TCP 커넥션이 지속적으로 사용되지 않음
	-> 커넥션을 이으면 오브젝트를 최대 1개만 전송하고 커넥션을 해제함
	-> 일정 오브젝트의 갯수만큼만 커넥션을 설정,해제해야해서 효율적이지 않다!
	-> HTTP 1.0의 방식이다.

Persistent HTTP

	-> 커넥션을 한번 설정하면 여러 오브젝트를 전송할 수 있음
	-> HTTP 1.1의 방식이다.


------------------------------------------------------------------------------------------------
p. 20

Non-Persistent HTTP의 동작방식

	-> 유저가 URL을 브라우저에 입력했다.
	1. HTTP client가 TCP connection을 HTTP server에 요청한다 (요청 메시지가 있음)
	2. HTTP가 이 커넥션을 설정할 지 내부적으로 검토함 (설정할 자원이 있는지 확인 등)
	3. 응답 메시지를 HTTP client에 보낸다
	4. HTTP client가 HTTP server에 request message를 보낸다 (URL을 이제야 전송함)
	5. HTTP server가 수신을 하면 response message를 전송(object가 담겨있음 (base-HTML))
	6. HTTP client가 response를 받고나면 server가 TCP connection을 해제한다
	7. HTTP client는 HTML을 화면에 display한다
	8~ base object이후에 필요한 object 수만큼 위의 과정을 반복하며 object를 하나씩 받아온다


------------------------------------------------------------------------------------------------
p. 22

RTT : Round Trip Time의 약자로, 메시지가 서버까지 갔다가 다시 오는데 걸리는 시간

	-> TCP connection 메시지를 server에서 처리하는데는 매우 빠름!
	-> HTTP response, request를 받아 처리하는데는 일정 시간이 필요할 수 있음!

	-> 전체 시간 : 2RTT + transmit time

------------------------------------------------------------------------------------------------
p. 23

처음에는 base HTML 오브젝트를 받고

	이후에는 만약 10개의 object가 필요하다고 하면 다시 10번의 과정을 반복함
	-> 총 11번의 과정

	embedded object : reference object와 같은 의미
			-> base-HTML에 적힌 object들	

------------------------------------------------------------------------------------------------
p. 24

Persistent HTTP의 동작방식

	-> 이전의 non-persistent는 오브젝트마다 2RTT의 시간이 필요했다
		-> 또, TCP커넥션마다 OS의 overhead가 있다.
		-> 레퍼런스 오브젝트에 대해서는 병렬적으로 TCP커넥션을 열수 있다.

	-> Non-persistent에서의 TCP connection은 overhead를 가져옴
	-> 이를 개선한것이 Persistent이다!

------------------------------------------------------------------------------------------------
p. 25

처음에 TCP connection에 RTT1번
	, base HTML에 RTT 1번
	, 2개의 object에 RTT 2번의 시간이 든다


	Persistent는 overhead를 줄여주고 Connection setup의 딜레이는 줄여주지만
	-> non-persistent에서는 병렬처리가 가능하기 때문에
	-> 어떤 경우에는 persistent가 어떤 경우에는 non-persistent가 효율적이다.

	-> Persistent에서는 non-persistent에서처럼 병렬이 되지 않는다.


------------------------------------------------------------------------------------------------
p. 26

HTTP message

	-> request와 response가 있다.
	-> request message는 아스키코드값이다




------------------------------------------------------------------------------------------------
p. 28

POST method
	-> URL을 요청하는 경우의 메시지에 사용
	-> 서버에 input을 entity body에 넣어 올린다
		-> URL이 input을 요구할때 input을 같이 올리는것

GET method
	-> HTML이나 오브젝트를 받는 메시지에 사용
	-> 


------------------------------------------------------------------------------------------------
p. 28


	PUT은 URL이 input을 요구하지 않아도 같이 input을 올리는것
		-> 보통은 잘 허용, 사용하지 않음

	DELETE : 웹 서버에 있는 파일을 delete하고 싶을 때 사용
		-> 원격에서 device에 접속해서 설정, 셋업할때 주로 사용


------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









------------------------------------------------------------------------------------------------
p. 









