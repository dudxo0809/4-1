p. 2

이번 챕터에서는 네트워크의 구조에 대해 좀 더 살펴본다
	
	-> 지연시간과 관련해 한번더 짚어본다
	-> 프로토콜의 계층구조를 살펴본다
	-> 각 계층이 제공하는 서비스 모델이 어떤것이 있는가
	-> 네트워크 운영구조와 인터넷의 역사에대해 알아본다

------------------------------------------------------------------------------------------------
p. 3

인터넷의 구조

	-> 기본적으로 네트워크가 모인 네트워크
	-> 각 단말기는 접근망을 통해 인터넷으로 연결함
	
	-> 각 단말기는 ISP에 연결됨 (Internet Service Providers)
	-> 다시 각 ISP는 서로 연결되어 단말기끼리 연결되게 됨
		-> end-to-end 통신이 가능하게 됨

------------------------------------------------------------------------------------------------
p. 4~7

각 access net에 단말기가 연결되어 있다고 해보자
	-> ex.) 파란색은 각각 광운대의 net, 세종대의 net 등등...
	-> 광운대와 세종대의 단말기가 연결되려면
		-> 모든 access net이 각각 연결되어있어야 한다
		-> but, 매우 복잡하고 링크가 너무 많이 필요하게 된다.
		-> 확장성이 좋지 않다!!

따라서 Global ISP를 두고 access net은 이 ISP를 경유해서 
	다른 access net과 통하게 한다.	
	-> 이 ISP는 access net에 위탁을 받아 경제적 이득을 취할 수 있다.

	-> 여러개의 경쟁 ISP가 생기게 된다
	-> 따라서 여러개의 ISP는 서로 연결할 수 있는 
	-> Perring link 가 필요하다!!!

------------------------------------------------------------------------------------------------
p. 8, 9

만약 Global ISP가 점점 늘어나면 perring link의 갯수가 크게 늘어난다!

	-> 따라서 access net을 ISP가 연결했듯이
	-> ISP를 IXP가 연결한다. (Internet exchange point)
	-> IXP는 peering link보다 경제적인 infrastructure를 갖춘다.

점점 access net이 늘어나면서 Global ISP가 감당하기 힘들어 진다
	-> 이를 커버하기 위해 regional net이 등장
	-> ex.) 미국의 각 주를 담당하는 regional net


------------------------------------------------------------------------------------------------
p. 10

어떤 회사는 자신의 컨텐츠를 잘 운영하기 위해
	-> 독자적인 망을 구성하기도 한다
	-> ex.) 구글, 아마존 등...



------------------------------------------------------------------------------------------------
p. 11, 12

access ISP < regional ISP < IXP < Tier 1 ISP 

미국의 Sprint사가 운영하는 global ISP망 (티어 1)
	-> 미국 전체를 커버하는 ISP망
	-> 소외된 지역은 regional ISP가 커버함

POP는 외부의 다른 ISP망이 노출이 되는 인터페이스 역할을 하는 지점이다.

------------------------------------------------------------------------------------------------
p. 13

2003년 우리나라의 인터넷 구조

	-> 각 하늘색 사각형은 IXP임 : 각 IXP마다 연결된 ISP가 여러개 존재





------------------------------------------------------------------------------------------------
p. 17

왜 딜레이가 생기는가? 

	-> 라우터에서 다른 라우터로 전송하는 속도가
	-> 단말기에서 라우터로 패킷을 전송하는 속도보다 느리게 되면
	-> 라우터에서 패킷들이 queue에 대기상태가 됨
		-> delay 발생!!!

	딜레이 : 패킷이 전송되는데 까지 걸리는 시간 + 패킷이 큐에서 기다리는 시간
	로스 : 큐가 꽉차 새로 들어온 패킷이 사라짐

------------------------------------------------------------------------------------------------
p. 18

전체 딜레이는 아래 4가지를 모두 합친값이다.

1. 큐 웨이팅 딜레이
2. 전송 딜레이
3. 링크를 타고가는 딜레이 (빛의속도)
4. Nodal processing 딜레이
	-> bit에 에러가있는지 확인 & 어느 outport로 패킷을 보낼지 선택하는 시간
	-> 예측이 힘들고 심각한 현상이 발생 될 수 있다.
	-> 네트워크 구조에 따라 시간이 달라짐


------------------------------------------------------------------------------------------------
p. 19

Propagation delay

	-> 한 라우터에서 다른 라우터로 패킷이 전송되는데 걸린 시간
	-> 빛의 속도
	-> 링크의 물리적인 거리를 빛의 속도로 나눈 값이 delay time

*** Transmission 과 Propagation을 혼동하지 말것!!!!!***
	-> Transmission : 비트의 길이를 속도로 나눈것!

------------------------------------------------------------------------------------------------
p. 20

Queueing Delay

	-> 큐잉 딜레이는 예측이 어렵다!
		-> 사용자에 따라 항상 달라지기 때문
	-> 단위시간당 패킷이 나가는양보다 들어오는 양이 더 많을때
	-> La : 단위시간당 들어오는 비트의 양 (패킷당비트수/단위시간당패킷수 = 단위시간당비트수)
	-> La/R : 들어오는 양 대비 나가는 양이 어느정도인가?

	-> Intensity가 0에 가까우면 딜레이가 줄고, 1에 가까우면 딜레이가 점점 커진다
		-> 만약 1보다 크다면 딜레이는 Infinite이다!!

	-> 그래프를 보면 intensity가 1보다 아직 작음에도 딜레이가 infinite로 가고 있다?
		-> 실제 R은 이론상의 R보다 더 작다!
		-> 따라서 전송속도가 줄어들수밖에 없다

------------------------------------------------------------------------------------------------
p. 21

Packet Loss

	-> 큐의 저장 장소는 유한한 길이를 가진다
	-> 만약 패킷이 도착했는데 큐가 꽉 찼자면 queue drop이 일어난다!
	-> lost packet은 다시 이전의 노드로 재전송된다
		-> 딜레이가 더 악화된다



------------------------------------------------------------------------------------------------
p. 22, 23

Throughput

	-> 단위시간당 전송하는 비트의 양
	-> Sender와 Receiver간의 전송량/시간 을 말함
		-> 특정 링크에서의 속도가 아님!

	-> Sender에서 보낸 양, Receiver에서 받은양은 다를 수 있다
		-> 링크마다 속도가 다르기 때문에
	-> 두 링크에서의 속도가 다를때, 더 throughput(속도)가 작은 링크의 속도가 Throughput이 된다



------------------------------------------------------------------------------------------------
p. 24

만약 여러 패킷이 R이라는 백본 링크를 같이 통과할때

	-> 여기서 R은 동등하게 서킷을 나눠 패킷을 전송해줌
	-> 한 단말기에서 다른 단말기로 지나가는데 통과하는 여러 링크중
		-> 가장 throughput이 작은 링크의 throughput을 따른다
	



------------------------------------------------------------------------------------------------
p. 25

Protocol Layers

	-> 프로토콜은 겹겹히 계층구조를 이루고 있다.
	-> 다양하고 복잡한 문제를 해결해야하는 시스템을 운영하기 위해서
		-> 모듈별로 나눠 설계,구현,운영했다.



------------------------------------------------------------------------------------------------
p. 26, 27

만약 한 단말기에서 다른 단말기로 메일을 보낸다고 가정해보자

	-> 양쪽에서 취해야할 동작들이 있다. 이런 절차를 규명한것이 프로토콜이다.
	-> 메일을 보낼때 가상의 파이프를 통해 메시지를 하나씩 잘라 순차적으로 보낸다
		-> 보낸 순서대로 조합해서 정상적으로 메일을 받을 수 있다
		-> 이렇게 순차적으로 잘라 보내고 받는것이 Transport Layer이다.
		-> 이 동작을 위해 있는것이 Transport Layer Protocol이다



------------------------------------------------------------------------------------------------
p. 28

Network Layer

	-> 실제로는 파이프가 아니라 링크들과 라우터들을 통과해야한다
	-> 통과할 수 있는 길이 여러가지 있다.
		-> 만약 오는중에 패킷의 순서가 바뀌었다면?
		-> 이를 재조합하고 처리하는게 Network Layer

------------------------------------------------------------------------------------------------
p. 29

Data Link Layer

	-> 



------------------------------------------------------------------------------------------------
p. 30

왜 Layering을 하는가?

	응용계층, 전송계층, 네트워크레이어 계층, 데이터링크계층 이 있다.
	-> 응용은 전송의, 전송은 네트워크의, 네트워크는 데이터링크 계층의 도움을 받아 기능한다
	-> 각 4개의 계층이 단계별로 윗 계층의 레이어에 기능을 제공한다.



------------------------------------------------------------------------------------------------
p. 31

인터넷의 레이어에는 총 5개의 레이어가 있다

	Physical



------------------------------------------------------------------------------------------------
p. 32

ISO에서는 7개의 레이어를 사용하도록 권장하고 있다.

	-> 표준모델
	-> 각 계층에서의 api가 정의되어있음


------------------------------------------------------------------------------------------------
p. 33

Encapsulation
	-> 캡슐화 (헤더가 붙는것) , Decapsulation : 헤더가 떨어지는것

	-> 응용계층에서 메시지를 전달할때
	-> 단말기에서 단말기로 : 응용계층에서 응요계층으로 전달된다
	-> 실제 응용과 응용사이에 여러 계층을 여러번 통과한다

	-> 전송계층에서 메시지앞에 헤더가 붙음 (헤더는 다음계층에서 쓰임)
		-> segment로 바뀜
	-> 네트워크계층에서 다시 헤더가 붙어서 datagram이 됨
	-> 링크계층에서 헤더가 붙어(앞뒤로) frame이 됨

	-> 라우터로 들어와 윗계층으로 올라갈때마다 헤더가 하나씩 벗겨짐
	-> 다시 아래계층으로 내려올때마다 헤더가 하나씩 붙음

	-> 메시지가 전송될때 source와 destination의 IP주소는 절대 변하지 않는다
	-> but, 몇개의 라우터를 지나왔는지, 다음라우터의 정보 등은 변할수있다.
		-> 변하는 정보, 변하지않는정보가 있음

------------------------------------------------------------------------------------------------
p. 34~38

인터넷의 역사

	



------------------------------------------------------------------------------------------------
p. 39

요약

	프로토콜, 인터넷의 구조, 
	성능(로스, 딜레이), 프로토콜의 레이어구조 등





------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 40

응용계층에서 기능을 사용하려면 아래 계층에서의 기능을 가져다 써야한다

	-> 아래계층의 기능(API)은 OS상에 탑재되어있다.
	-> 하지만 응용계층에선 아래계층에서의 일이 잘되는지 확인할 수 없다
	-> 이를 와이어 샤크로 확인할 수 있다!!

	-> OS내에서 어떤 중간과정을 거치고 있는지 확인할 수 있다!
	->패킷캡쳐라능 기능
	-> decapsulation과정에서 패킷의 정보를 빼냄
	-> 패킷단위로 정보를 확인할 수 있음

	-> 우리는 유저 인터페이스를 이용해서 동작을 확인하는 실습을 진행할것
	-> 구현x
	-> 툴을 사용해서 동작을 확인하는 과제가 나갈것
	-> pdf를 통해 공부하고 과제 진행

------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
