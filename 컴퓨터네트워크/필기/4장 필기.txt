p. 3

지난 시간까지 Application Layer를 공부했고

이제 Transport Layer를 공부한다.

	-> transport layer의 원리를 공부한다.
	-> 이 레이어의 인터넷에서의 프로토콜을 공부한다.
		-> UDP, TCP


------------------------------------------------------------------------------------------------
p. 5

양단에 호스트가 있음
	-> 양쪽을 잇는 가상의 파이프
	-> 이것을 만드는게 transport service
		-> app process 간의 논리적 커뮤니케이션

	Transport protocol은 End system에서 동작한다!!!
	-> 보내는쪽에서 메시지를 세그먼트로 나눠 네트워크 레이어로 보냄
	-> 받는쪽이 세그먼트를 재조합해 app 레이어로 보냄!!

	-> 커넥션 없이 보내는게 UDP. 커넥션이 있는게 TCP

------------------------------------------------------------------------------------------------
p. 6

UDP를 사용하는것은 network레이어를 그대로 사용하는것?
	네트워크 레이어는 호스트간의 커넥션없이 로지컬한 소통을 하는것
	UDP는 프로세스간에 커넥션 없이 로지컬한 소통을 하는것
	-> 두개가 비슷하다!


네트워크레이어와 트랜스포트레이어의 차이점!

	-> 네트워크레이어는 신뢰성이 낮다. : 이를 그대로 사용하는게 UDP
		-> 이를 문제가 없게 커넥션을 만드는게 TCP방식


------------------------------------------------------------------------------------------------
p. 7

신뢰성이 있고, 세그먼트의 순서가 뒤바뀌지않는 TCP
		
신뢰성이 없고 순서가 정리되지않는 UDP

이 트랜스포트 레이어의 프로토콜 두개는 딜레이가 보장이 되지 않고, 전송량도 보장이 안된다.

------------------------------------------------------------------------------------------------
p. 8

멀티플렉싱과 디멀티플렉싱

https://snnchallenge.tistory.com/127

	-> 디멀티플렉싱은 여러 데이터를 섞어서 보내는것 (트랜스포트레이어로 와서 섞이는것)
		-> 여러 클라이언트에서 서버의 트랜스포트레이어로 온것을
		-> 알맞게 호스트로 잘 나눠 보냄
	-> 디멀티플렉싱
		-> 데이터가 트랜스포트로 들어와서 섞여존재하게 됨
		-> 

	?? 헷갈림
------------------------------------------------------------------------------------------------
p. 9

디멀티 플렉싱이 어떻게 동작하나

	-> 





------------------------------------------------------------------------------------------------
p. 10

두개의 소켓을 만들고, 포트넘버를 지정함	
UDP 소켓은 IP주소와 포트넘버로 identify된다



소스포트넘버는 return address를 제공한다.


------------------------------------------------------------------------------------------------
p. 12

앱 레이어에 세그먼트를 보낼때 connection oriented 서비스이기때문에
	-> 어떤 커넥션인지를 알아야 하기때문에
	4개의 tuple이 필요하다.


------------------------------------------------------------------------------------------------
p. 13

서로 다른 호스트 에서 들어오는 세그먼트들

세개의 커넥션

TCP는 호스트의 포트넘버도 필요함


------------------------------------------------------------------------------------------------
p. 15

UDP : User Datagram Protocol

	-> 성능보장을 못한다는 특징
	-> 신뢰성이 없다 (loss가 있을 수 있음)

	-> Connectionless이다 (가상의 커넥션(파이프)을 형성하지 않음)
	-> 파이프가 없으므로 신뢰성이 떨어지고, 순서가 뒤바뀔 수 있음

	-> 커넥션 셋업과정이 필요없으므로 빠르다
	-> 각 UDP segment는 커넥션이 없으므로 독립적으로 다뤄진다.

	UDP의 장점 확인!
	*** 이렇게 박스로 강조된것은 반드시 확인할것!!! ***

------------------------------------------------------------------------------------------------
p. 16

application data의 길이는 가변적이므로,

Length에서 전체 UDP segment의 길이를 표시한다.

Checksum : UDP segment가 전송되는과정에서 에러가 있었는지 체크함


------------------------------------------------------------------------------------------------
p. 17

UDP Checksum

	-> UDP segment의 에러발생여부를 확인하기 위한 알고리즘

	Sender가 segment를 16bit 단위로 자른다
	-> 그 후 checksum을 계산하고, checksum필드에 넣음

	Receiver가 checksum의 값을 계산해서, checksum필드의 값과 비교함
	-> 만약 값이 같다면 에러가 없다는 뜻!

	-> 체크섬까지 더해서 결과가 전부 0이나오는지 확인하는 방법이 더 좋다
	*** 시험문제!!!! *** (사진 따로 첨부함)
	-> 위의 모든 비트를 자릿수에 맞게 더하면, sum이 나옴
	-> 이 sum에 carry된 bit를 더함
	-> 최종 sum의 bit를 뒤집음 (이게 check sum이 됨)

	-> 이제 receiver에서 sum을 계산하는데, 이때는 checksum값까지 같이 더함
	-> sender때와 마찬가지로 carry된 bit도 더함
	-> 최종 sum값의 bit를 뒤집으면 0000이 될것!
	-> 만약 이 checksum의 모든 bit가 0이 아니라면 에러인것이다!!!
	
------------------------------------------------------------------------------------------------
p. 19

Reliable Data Transfer : 신뢰성이있는 데이터 전송

	-> app계층에서 메시지를 segment화 해서 transport계층으로 보냄
	-> 파이프를 통해 이동 후 리시버가 받음

	사실은...?

------------------------------------------------------------------------------------------------
p. 20 ~

실제로는

네트워크 계층에서의 Unreliable channel (신뢰성이 없는 파이프)
	-> 에서 데이터가 이동됨

Transport Layer에서는 왼쪽 그림처럼 보이지만
사실 오른쪽그림같은 일이 일어난다.

	-> Sender side에서 패킷을 세그먼트화 해서 네트워크 계층으로 보냄
	-> 

------------------------------------------------------------------------------------------------
p. 24

rdt 1.0 

	-> Sending : 위에서 메시지가 내려오면 
		-> make_pkt() : segment format에 맞게 segment를 만듬 (encapsulation)
		-> udt_send() : 패킷을 넣어서 보냄
		-> 반복... : 다른메시지를 기다림

	-> Receiver : 아래에서 패킷이 들어오면
		-> extract() : 패킷에서 데이터를 추출함
		-> deliver_data() : 데이터를 위로 넘겨줌
		-> 반복... : 아래에서 올라올 다른 패킷을 기다림

------------------------------------------------------------------------------------------------
p. 25

rdt 2.0 : 이번엔 1bit에러가 있다고 가정한다!

	-> underlying channel에서 일어난 에러
		-> 체크섬으로 확인하자!
	-> 만약 ACK를 받으면 에러가 없다, NAK를 받으면 에러가 있다!
		-> NAK를 받으면 다시 보내줘야함


------------------------------------------------------------------------------------------------
p. 26

Sender가 segment를 보내고 state가 바뀜 (기다림)
	-> 만약 NAK를 받으면 재전송 (ACK를 받을때까지 기다림)
	-> ACK를 받으면 state가 바뀌고 다른 data를 기다림

	isNAK : NAK를 받았는지 확인
	corrupt : 패킷에 체크섬 계산에 오류가 있는지 : 있으면 NAK를 보냄
	notcorrupt : 패킷에 체크섬 오류가 없는지 : 없으면 ACK를 보냄

------------------------------------------------------------------------------------------------
p. 







------------------------------------------------------------------------------------------------
