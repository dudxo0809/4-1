p. 3

지난 시간까지 Application Layer를 공부했고

이제 Transport Layer를 공부한다.

	-> transport layer의 원리를 공부한다.
	-> 이 레이어의 인터넷에서의 프로토콜을 공부한다.
		-> UDP, TCP


------------------------------------------------------------------------------------------------
p. 5

양단에 호스트가 있음
	-> 양쪽을 잇는 가상의 파이프
	-> 이것을 만드는게 transport service
		-> app process 간의 논리적 커뮤니케이션

	Transport protocol은 End system에서 동작한다!!!
	-> 보내는쪽에서 메시지를 세그먼트로 나눠 네트워크 레이어로 보냄
	-> 받는쪽이 세그먼트를 재조합해 app 레이어로 보냄!!

	-> 커넥션 없이 보내는게 UDP. 커넥션이 있는게 TCP

------------------------------------------------------------------------------------------------
p. 6

UDP를 사용하는것은 network레이어를 그대로 사용하는것?
	네트워크 레이어는 호스트간의 커넥션없이 로지컬한 소통을 하는것
	UDP는 프로세스간에 커넥션 없이 로지컬한 소통을 하는것
	-> 두개가 비슷하다!


네트워크레이어와 트랜스포트레이어의 차이점!

	-> 네트워크레이어는 신뢰성이 낮다. : 이를 그대로 사용하는게 UDP
		-> 이를 문제가 없게 커넥션을 만드는게 TCP방식


------------------------------------------------------------------------------------------------
p. 7

신뢰성이 있고, 세그먼트의 순서가 뒤바뀌지않는 TCP
		
신뢰성이 없고 순서가 정리되지않는 UDP

이 트랜스포트 레이어의 프로토콜 두개는 딜레이가 보장이 되지 않고, 전송량도 보장이 안된다.

------------------------------------------------------------------------------------------------
p. 8

멀티플렉싱과 디멀티플렉싱

https://snnchallenge.tistory.com/127

	-> 디멀티플렉싱은 여러 데이터를 섞어서 보내는것 (트랜스포트레이어로 와서 섞이는것)
		-> 여러 클라이언트에서 서버의 트랜스포트레이어로 온것을
		-> 알맞게 호스트로 잘 나눠 보냄
	-> 디멀티플렉싱
		-> 데이터가 트랜스포트로 들어와서 섞여존재하게 됨
		-> 

	?? 헷갈림
------------------------------------------------------------------------------------------------
p. 9

디멀티 플렉싱이 어떻게 동작하나

	-> 





------------------------------------------------------------------------------------------------
p. 10

두개의 소켓을 만들고, 포트넘버를 지정함	
UDP 소켓은 IP주소와 포트넘버로 identify된다



소스포트넘버는 return address를 제공한다.


------------------------------------------------------------------------------------------------
p. 12

앱 레이어에 세그먼트를 보낼때 connection oriented 서비스이기때문에
	-> 어떤 커넥션인지를 알아야 하기때문에
	4개의 tuple이 필요하다.


------------------------------------------------------------------------------------------------
p. 13

서로 다른 호스트 에서 들어오는 세그먼트들

세개의 커넥션

TCP는 호스트의 포트넘버도 필요함


------------------------------------------------------------------------------------------------
p. 15

UDP : User Datagram Protocol

	-> 성능보장을 못한다는 특징
	-> 신뢰성이 없다 (loss가 있을 수 있음)

	-> Connectionless이다 (가상의 커넥션(파이프)을 형성하지 않음)
	-> 파이프가 없으므로 신뢰성이 떨어지고, 순서가 뒤바뀔 수 있음

	-> 커넥션 셋업과정이 필요없으므로 빠르다
	-> 각 UDP segment는 커넥션이 없으므로 독립적으로 다뤄진다.

	UDP의 장점 확인!
	*** 이렇게 박스로 강조된것은 반드시 확인할것!!! ***

------------------------------------------------------------------------------------------------
p. 16

application data의 길이는 가변적이므로,

Length에서 전체 UDP segment의 길이를 표시한다.

Checksum : UDP segment가 전송되는과정에서 에러가 있었는지 체크함


------------------------------------------------------------------------------------------------
p. 17

UDP Checksum

	-> UDP segment의 에러발생여부를 확인하기 위한 알고리즘

	Sender가 segment를 16bit 단위로 자른다
	-> 그 후 checksum을 계산하고, checksum필드에 넣음

	Receiver가 checksum의 값을 계산해서, checksum필드의 값과 비교함
	-> 만약 값이 같다면 에러가 없다는 뜻!

	-> 체크섬까지 더해서 결과가 전부 0이나오는지 확인하는 방법이 더 좋다
	*** 시험문제!!!! *** (사진 따로 첨부함)
	-> 위의 모든 비트를 자릿수에 맞게 더하면, sum이 나옴
	-> 이 sum에 carry된 bit를 더함
	-> 최종 sum의 bit를 뒤집음 (이게 check sum이 됨)

	-> 이제 receiver에서 sum을 계산하는데, 이때는 checksum값까지 같이 더함
	-> sender때와 마찬가지로 carry된 bit도 더함
	-> 최종 sum값의 bit를 뒤집으면 0000이 될것!
	-> 만약 이 checksum의 모든 bit가 0이 아니라면 에러인것이다!!!
	
------------------------------------------------------------------------------------------------
p. 19

Reliable Data Transfer : 신뢰성이있는 데이터 전송

	-> app계층에서 메시지를 segment화 해서 transport계층으로 보냄
	-> 파이프를 통해 이동 후 리시버가 받음

	사실은...?

------------------------------------------------------------------------------------------------
p. 20 ~

실제로는

네트워크 계층에서의 Unreliable channel (신뢰성이 없는 파이프)
	-> 에서 데이터가 이동됨

Transport Layer에서는 왼쪽 그림처럼 보이지만
사실 오른쪽그림같은 일이 일어난다.

	-> Sender side에서 패킷을 세그먼트화 해서 네트워크 계층으로 보냄
	-> 

------------------------------------------------------------------------------------------------
p. 24

rdt 1.0 

	-> Sending : 위에서 메시지가 내려오면 
		-> make_pkt() : segment format에 맞게 segment를 만듬 (encapsulation)
		-> udt_send() : 패킷을 넣어서 보냄
		-> 반복... : 다른메시지를 기다림

	-> Receiver : 아래에서 패킷이 들어오면
		-> extract() : 패킷에서 데이터를 추출함
		-> deliver_data() : 데이터를 위로 넘겨줌
		-> 반복... : 아래에서 올라올 다른 패킷을 기다림

------------------------------------------------------------------------------------------------
p. 25

rdt 2.0 : 이번엔 1bit에러가 있다고 가정한다!

	-> underlying channel에서 일어난 에러
		-> 체크섬으로 확인하자!
	-> 만약 ACK를 받으면 에러가 없다, NAK를 받으면 에러가 있다!
		-> NAK를 받으면 다시 보내줘야함


------------------------------------------------------------------------------------------------
p. 26

Sender가 segment를 보내고 state가 바뀜 (기다림)
	-> 만약 NAK를 받으면 재전송 (ACK를 받을때까지 기다림)
	-> ACK를 받으면 state가 바뀌고 다른 data를 기다림

	isNAK : NAK를 받았는지 확인
	corrupt : 패킷에 체크섬 계산에 오류가 있는지 : 있으면 NAK를 보냄
	notcorrupt : 패킷에 체크섬 오류가 없는지 : 없으면 ACK를 보냄

------------------------------------------------------------------------------------------------
p. 27, 28

만약 Sender가 보낸것이 에러가 있었다면

	-> corrupt일 것이고, 에러가 없었다면 notcorrupt일것이다.
	-> corrupt : NAK를 만들어 Sender로 보냄
	-> notcorrupt : ACK를 만들어 Sender로 보냄

	-> Sender의 2번째 state에서 ACK 또는 NAK를 받으면
	-> ACK : isACK가 true이므로 state1으로 돌아감
	-> NAK : isNAK가 true이므로 다시  state2에 머물고 sndpkt를 다시 Receiver로 보냄


------------------------------------------------------------------------------------------------
p. 29

sender->receiver에서만 비트에러가 발생하는건 아니다!

반대로 receiver->sender에서 비트에러가 발생하면?

	ACK/NAK를 구분하지 못하면??
	-> 두개가 바뀌거나 구분하지 못할때

	패킷이 중복해서 들어올때
	-> 이를 방지하기 위해 sequence number 를 사용


------------------------------------------------------------------------------------------------
p.30	(이 FSM이 어떻게 동작하는지 시험문제 나올것!!!)

rdt 2.1

여기부턴 패킷에 seq# : 시퀀스 번호가 붙는다!

센더
	-> 두개의 시퀀스 번호만 사용함 : 0과 1 (중복이 아닌 패킷일때만 seq#을 바꾸면 됨)
		-> 재전송이면 seq#가 같으므로 구분이 가능함!
	-> ACK/NAK 를 check하는 함수가 필요
	-> state가 2배로 늘어남!

리시버
	-> packet이 복제된것인지 확인하는 함수 필요
	-> 단, 리시버는 자신이 보낸 ACK, NAK가 센더에 잘 보내졌는지 확인할 수 없다


------------------------------------------------------------------------------------------------
p. 31

(이 FSM 확실하게 이해할것!)

S0 : 데이터가 내려오는것을 기다리는 상태
	-> 패킷 시퀀스 0번

S1 : 리시버로 부터 ACK나 NAK를 기다리는 상태
	-> 시퀀스0번에 해당하는 ACK/NAK
	-> 다음 state로 넘어가려면 (패킷을 받고 && 패킷이 corrupt되지 않고 && ACK일때)

S2 : 데이터가 내려오길 기다리는 상태
	-> 패킷 시퀀스 1번

S3 : S1과 비슷하지만, 패킷시퀀스 번호만 1임

** S0과 S2, S1과 S3은 패킷 시퀀스 번호만 다르고 동작방식은 동일함

------------------------------------------------------------------------------------------------
p.32

리시버에서도 state가 2배로 늘어남!

S0 : 패킷 시퀀스넘버 0의 패킷을 기다림
	-> 이를 받고 만약 패킷 시퀀스 넘버가 0이고 corrupt되지 않았다면?
	-> 패킷으로 부터 데이터를 추출하고, 이 데이터를 센더로 전송함
	-> 체크섬을 확인하고 ACK가 들어간 패킷을 센더로 보냄

	-> 만약 패킷이 corrupt되었다면?
	-> NAK를 센더로 보냄!

	-> 만약 받은 패킷 시퀀스 넘버가 1이면?
	-> 중복되어서 들어온것! (이번에 들어온것을 버린다)
	-> 이전에 보낸 ACK를 센더가 받지 못한것이므로 ACKㄹ르 다시보냄!

S1 : S0과 마찬가지, 패킷 시퀀스넘버가 1임


------------------------------------------------------------------------------------------------
p. 33, 34

rdt 2.2 : NAK를 없애는 프로토콜??

ACK가 시퀀스 넘버까지 포함
	-> 패킷이 corrupt되지 않고, ACK 의 시퀀스 번호가 맞을때 다음 state

리시버에서 시퀀스 번호가 맞지 않으면 : 센더가 재전송 한것이므로
	-> 그에 대해 한번더 ACK를 보내줌


------------------------------------------------------------------------------------------------
p. 35

rdt 3.0

채널에 에러가 있거나 패킷 로스가 있을때?

센더 : 센더가 데이터 패킷을 보내고 ACK를 기다리는 상황
	-> 만약 보낸 패킷이 손실이 났다면? (Packet Loss)
	-> 리시버는 안들어왔으니까 대기만 계속 하는중!
	-> 이러면 센더입장에서도 리시버한테 ACK가 안왔으므로 계속 대기...
		-> 데드락과 비슷한 상황

어떻게 해결?
	-> 일정 시간이 지나고 ACK가 돌아오지 않으면
	-> 문제가 발생했다고 인식!

	-> but, 적절한 시간은 어느정도 인가??
		-> 패킷loss가 아니라 큐에서 조금 지연된거라면?
		-> ACK가 늦게 오면 또 문제가 됨!! (리시버: 복제된 패킷 발생)
			-> 리시버가 ACK를 보낼때 seq#넣어서 센더는 이를 통해 중복이닞 확인가능
	-> 적절한 시간계산을 위한 타이머가 필요함!


------------------------------------------------------------------------------------------------
p. 36

S1 : 패킷이 corrupt되었거나, ACK의 seq#가 맞지 않을때(1일때) : state 그대로!
	-> 만약 time out되었을 경우 리시버로 재전송! (state는 그대로 : 기다림...)
	-> corrupt아니고, seq#도 맞으면 다음 state로 넘어감!

S2 : 


------------------------------------------------------------------------------------------------
p.37






------------------------------------------------------------------------------------------------
p. 40

파이프라인 프로토콜

패킷을 하나보내고 하나받는게 아니라
	여러개를 동시에 보냄

	go-Back-N : 프로젝트로 구현할것
	-> 이전에 잘된데까지는 놔두고 이상한데부터 다시시작


------------------------------------------------------------------------------------------------
p. 42

파이프라이닝은 utilization이 올라간다!

	-> 0.00027에서 0.0008로 약 3배가량 증가했다.
	-> 한번에 보내는 수만큼 증가했다. 



------------------------------------------------------------------------------------------------
p. 43

Go-Back-N

	-> 여러개를 한번에보내는데 그중 일부에 문제가 생겼다.

	네모 : 패킷
	Window : 저장소, 최대용량 N

	진한초록 : 저장을했다가 ACK가 왔기 때문에 재전송이 필요없는 것 (전송 완료)
	연한초록 : 저장되어있고 패킷을 보냈지만 아직 ACK가 않온것
	회색 : 저장되어있고, 아직 보내지 않은것
	흰색 : 아직 패킷이 내려오지 않음

	시퀀스 번호는 k-bit를 지닌다
	Window size는 N이다.
	ACK에도 seq번호가 들어가야한다. n-bit 시퀀스 넘버 
		cumulative ACK : 빈곳이 없이 ACK가 모두 들어온 마지막 패킷의 seq번호 (누적 ACK)
		이 누적 ACK번호까지는 패킷이 잘 들어왔다는것을 의미!
	타이머 : 윈도우에 대해 대표 타이머 하나만 사용
		-> timeout(n) : n번째 이상의 윈도우 내의 패킷을 전부 재전송하는 함수
		-> n번째부터 윈도우 내의 모든 패킷을 다시 재전송하기때문에 go back n이다!!!
		-> 이렇게하면 재전송이 필요없는것도 재전송 할 수 있기때문에 효율적이지 않을 수 있다.
		-> 하지만 타이머가 하나면 되고, 판단이 빨리 끝나는 장점이 있다.


------------------------------------------------------------------------------------------------
p. 44, 45

Go-Back-N : Sender extended FSM

	Sender가 1,2,3 패킷을 한번에 보냈을 경우 
	ack가 3이 왔으면 1,2,3 모두 정상적으로 받았다는 것임



	Receiver는 버퍼가 없음
	잘못 전송돼 오면 걍 버리면 됨


------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






------------------------------------------------------------------------------------------------
p.






